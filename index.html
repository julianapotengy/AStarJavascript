<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>A* - Juliana Potengy</title>
    <style>
    	canvas { 
            background: #eee; 
            position:absolute;
            top: 0px;
            bottom: 0px;
            left: 0px;
            right: 0px;
            margin: auto; 
        }
    </style>
</head>
<body>
    
<canvas id="myCanvas" width="600" height="600"></canvas>
<script type="text/javascript" src="astar.js"></script>

<script>
	/*var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");
    var maxNodes = 10;
    var nodeSize = canvas.width / maxNodes;
    var manhattan;
    var nodeA, nodeB;*/
    //var weight;
        
    /*function Node(x, y, walkable) {
        this.x = x;
        this.y = y;
        this.walkable = walkable;
        
        ctx.beginPath();
        ctx.rect(x, y, nodeSize, nodeSize);
        ctx.strokeStyle = "rgba(0, 0, 255, 0.5)";
        ctx.stroke();
        ctx.closePath();
    }
    
    function NodeA(x, y, walkable) {
        this.x = x;
        this.y = y;
        this.walkable = walkable;
        
        ctx.beginPath();
        ctx.rect(x, y, nodeSize, nodeSize);
        ctx.fillStyle = "#00FF00";
        ctx.fill();
        ctx.closePath();
    }
    
    function NodeB(x, y, walkable) {
        this.x = x;
        this.y = y;
        this.walkable = walkable;
        
        ctx.beginPath();
        ctx.rect(x, y, nodeSize, nodeSize);
        ctx.fillStyle = "#FF0000";
        ctx.fill();
        ctx.closePath();
    }
    
    function NodeWall(x, y, walkable) {
        this.x = x;
        this.y = y;
        this.walkable = walkable;
        
        ctx.beginPath();
        ctx.rect(x, y, nodeSize, nodeSize);
        ctx.fillStyle = "#000000";
        ctx.fill();
        ctx.closePath();
    }
    
    var grid = new Grid(10, 10, 0);
    
    function Grid(width, height) {
        this.width = width;
        this.height = height;
        this.nodes = BuildNodes(width, height);
        
        nodeA = new NodeA(nodeSize * 4, nodeSize * 3, 0);
        nodeB = new NodeB(nodeSize * 4, nodeSize * 7, 0);
        
        NodeWall(nodeSize * 5, nodeSize * 5, 1);
        NodeWall(nodeSize * 4, nodeSize * 5, 1);
        NodeWall(nodeSize * 3, nodeSize * 5, 1);
    }
    
    function BuildNodes(width, height, matrix) {
        var i, j, nodes = new Array(height);
        
        for (i = 0; i < maxNodes; i++) {
            nodes[i] = new Array(width);
            for (j = 0; j < maxNodes; j++) {
                nodes[i][j] = new Node(i * nodeSize, j * nodeSize);
            }
        }
        
        if(matrix === undefined) {
            return nodes;
        }
        
        if(matrix.length !== height || matrix[0].length !== width) {
            throw new Error('Matrix size does not fit');
        }
        
        for(i = 0; i < height; ++i) {
            for(j = 0; j < width; ++j) {
                if(matrix[i][j]) {
                    nodes[i][j].walkable = false;
                }
            }
        }
        
        return nodes;
    }*/
    
    /*var graph = new Graph([
	   [1,1,1,1],
	   [0,1,1,0],
	   [0,0,1,1]
    ]);
    var start = graph.grid[0][0];
    var end = graph.grid[1][2];
    var result = astar.search(graph, start, end);
    console.log(result);
    
    function pathTo(node) {
        var current = node;
        var path = [];
        while (current.parent) {
        path.unshift(current);
        current = current.parent;
        }
    return path;
    }
    
    function getHeap() {
        return new BinaryHeap(function(node) {
        return node.f;
        });
    }
    
    var astar = {
        /**
        * Perform an A* Search on a graph given a start and end node.
        * @param {Graph} graph
        * @param {GridNode} start
        * @param {GridNode} end
        * @param {Object} [options]
        * @param {bool} [options.closest] Specifies whether to return the
             path to the closest node if the target is unreachable.
        * @param {Function} [options.heuristic] Heuristic function (see
        *          astar.heuristics).
        *
        search: function(graph, start, end, options) {
            graph.cleanDirty();
            options = options || {};
            var heuristic = options.heuristic || astar.heuristics.manhattan;
            var closest = options.closest || false;

            var openHeap = getHeap();
            var closestNode = start; // set the start node to be the closest if required

            start.h = heuristic(start, end);
            graph.markDirty(start);

            openHeap.push(start);

            while (openHeap.size() > 0) {

                // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
                var currentNode = openHeap.pop();

                // End case -- result has been found, return the traced path.
                if (currentNode === end) {
                    return pathTo(currentNode);
                }

                // Normal case -- move currentNode from open to closed, process each of its neighbors.
                currentNode.closed = true;

                // Find all neighbors for the current node.
                var neighbors = graph.neighbors(currentNode);

                for (var i = 0, il = neighbors.length; i < il; ++i) {
                    var neighbor = neighbors[i];

                    if (neighbor.closed || neighbor.isWall()) {
                        // Not a valid node to process, skip to next neighbor.
                        continue;
                    }

                    // The g score is the shortest distance from start to current node.
                    // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
                    var gScore = currentNode.g + neighbor.getCost(currentNode);
                    var beenVisited = neighbor.visited;

                    if (!beenVisited || gScore < neighbor.g) {

                        // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                        neighbor.visited = true;
                        neighbor.parent = currentNode;
                        neighbor.h = neighbor.h || heuristic(neighbor, end);
                        neighbor.g = gScore;
                        neighbor.f = neighbor.g + neighbor.h;
                        graph.markDirty(neighbor);
                        if (closest) {
                            // If the neighbour is closer than the current closestNode or if it's equally close but has
                            // a cheaper path than the current closest node then it becomes the closest node
                            if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {
                                closestNode = neighbor;
                            }
                        }

                        if (!beenVisited) {
                            // Pushing to heap will put it in proper place based on the 'f' value.
                            openHeap.push(neighbor);
                        } else {
                            // Already seen the node, but since it has been rescored we need to reorder it in the heap
                            openHeap.rescoreElement(neighbor);
                        }
                    }
                }
            }

            if (closest) {
                return pathTo(closestNode);
            }

            // No result was found - empty array signifies failure to find path.
            return [];
        },
        // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
        heuristics: {
            manhattan: function(pos0, pos1) {
                var d1 = Math.abs(pos1.x - pos0.x);
                var d2 = Math.abs(pos1.y - pos0.y);
                return d1 + d2;
            },
            diagonal: function(pos0, pos1) {
                var D = 1;
                var D2 = Math.sqrt(2);
                var d1 = Math.abs(pos1.x - pos0.x);
                var d2 = Math.abs(pos1.y - pos0.y);
                return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));
            }
        },
        cleanNode: function(node) {
            node.f = 0;
            node.g = 0;
            node.h = 0;
            node.visited = false;
            node.closed = false;
            node.parent = null;
        }
    };
    
    function Graph(gridIn, options) {
        options = options || {};
        this.nodes = [];
        this.diagonal = !!options.diagonal;
        this.grid = [];
        for (var x = 0; x < gridIn.length; x++) {
            this.grid[x] = [];

            for (var y = 0, row = gridIn[x]; y < row.length; y++) {
                var node = new GridNode(x, y, row[y]);
                this.grid[x][y] = node;
                this.nodes.push(node);
            }
        }
        //this.init();
    }
    
    Graph.prototype.init = function() {
        this.dirtyNodes = [];
        for (var i = 0; i < this.nodes.length; i++) {
            astar.cleanNode(this.nodes[i]);
        }
    };

    Graph.prototype.cleanDirty = function() {
        for (var i = 0; i < this.dirtyNodes.length; i++) {
            astar.cleanNode(this.dirtyNodes[i]);
        }
        this.dirtyNodes = [];
    };

    Graph.prototype.markDirty = function(node) {
        this.dirtyNodes.push(node);
    };

    Graph.prototype.neighbors = function(node) {
        var ret = [];
        var x = node.x;
        var y = node.y;
        var grid = this.grid;

        // West
        if (grid[x - 1] && grid[x - 1][y]) {
            ret.push(grid[x - 1][y]);
        }

        // East
        if (grid[x + 1] && grid[x + 1][y]) {
            ret.push(grid[x + 1][y]);
        }

        // South
        if (grid[x] && grid[x][y - 1]) {
            ret.push(grid[x][y - 1]);
        }

        // North
        if (grid[x] && grid[x][y + 1]) {
            ret.push(grid[x][y + 1]);
        }

        return ret;
    };

    Graph.prototype.toString = function() {
        var graphString = [];
        var nodes = this.grid;
        for (var x = 0; x < nodes.length; x++) {
            var rowDebug = [];
            var row = nodes[x];
            for (var y = 0; y < row.length; y++) {
                rowDebug.push(row[y].weight);
            }
            graphString.push(rowDebug.join(" "));
        }
        return graphString.join("\n");
    };
    
    function GridNode(x, y, weight) {
        this.x = x;
        this.y = y;
        this.weight = weight;
    }
    
    GridNode.prototype.toString = function() {
        return "[" + this.x + " " + this.y + "]";
    };
    
    GridNode.prototype.getCost = function(fromNeighbor) {
        // Take diagonal weight into consideration.
        if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
            return this.weight * 1.41421;
        }
        return this.weight;
    };
    
    GridNode.prototype.isWall = function() {
        return this.weight === 0;
    };
    
    function BinaryHeap(scoreFunction) {
        this.content = [];
        this.scoreFunction = scoreFunction;
    }
    
    BinaryHeap.prototype = {
        push: function(element) {
        // Add the new element to the end of the array.
        this.content.push(element);

        // Allow it to sink down.
        this.sinkDown(this.content.length - 1);
        },
        pop: function() {
            // Store the first element so we can return it later.
            var result = this.content[0];
            // Get the element at the end of the array.
            var end = this.content.pop();
            // If there are any elements left, put the end element at the
            // start, and let it bubble up.
            if (this.content.length > 0) {
                this.content[0] = end;
                this.bubbleUp(0);
            }
            return result;
        },
        remove: function(node) {
            var i = this.content.indexOf(node);

            // When it is found, the process seen in 'pop' is repeated
            // to fill up the hole.
            var end = this.content.pop();

            if (i !== this.content.length - 1) {
                this.content[i] = end;

                if (this.scoreFunction(end) < this.scoreFunction(node)) {
                    this.sinkDown(i);
                } else {
                    this.bubbleUp(i);
                }
            }
        },
        size: function() {
            return this.content.length;
        },
        rescoreElement: function(node) {
            this.sinkDown(this.content.indexOf(node));
        },
        sinkDown: function(n) {
            // Fetch the element that has to be sunk.
            var element = this.content[n];

            // When at 0, an element can not sink any further.
            while (n > 0) {

                // Compute the parent element's index, and fetch it.
                var parentN = ((n + 1) >> 1) - 1;
                var parent = this.content[parentN];
                // Swap the elements if the parent is greater.
                if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                    this.content[parentN] = element;
                    this.content[n] = parent;
                    // Update 'n' to continue at the new position.
                    n = parentN;
                }
                // Found a parent that is less, no need to sink any further.
                else {
                    break;
                }
            }
        },
        bubbleUp: function(n) {
            // Look up the target element and its score.
            var length = this.content.length;
            var element = this.content[n];
            var elemScore = this.scoreFunction(element);

            while (true) {
                // Compute the indices of the child elements.
                var child2N = (n + 1) << 1;
                var child1N = child2N - 1;
                // This is used to store the new position of the element, if any.
                var swap = null;
                var child1Score;
                // If the first child exists (is inside the array)...
                if (child1N < length) {
                    // Look it up and compute its score.
                    var child1 = this.content[child1N];
                    child1Score = this.scoreFunction(child1);

                    // If the score is less than our element's, we need to swap.
                    if (child1Score < elemScore) {
                        swap = child1N;
                    }
                }

                // Do the same checks for the other child.
                if (child2N < length) {
                    var child2 = this.content[child2N];
                    var child2Score = this.scoreFunction(child2);
                    if (child2Score < (swap === null ? elemScore : child1Score)) {
                        swap = child2N;
                    }
                }

                // If the element needs to be moved, swap it, and continue.
                if (swap !== null) {
                    this.content[n] = this.content[swap];
                    this.content[swap] = element;
                    n = swap;
                }
                // Otherwise, we are done.
                else {
                    break;
                }
            }
        }
    };
    
    /*function getNodeAt(x, y) {
        return this.nodes[y][x];
    }
    function isWalkableAt(x, y) {
        return this.isInside(x, y) && this.nodes[y][x].walkable;
    }
    function isInside(x, y) {
        return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
    }
    function setWalkableAt(x, y, walkable) {
        this.nodes[y][x].walkable = walkable;
    }
    function getClosestNodes(node) {
        var x = node.x,
            y = node.y,
            neighbors = [],
            n0 = false, n1 = false, n2 = false, n3 = false,
            nodes = this.nodes;
        
        // cima
        if (this.isWalkableAt(x, y - 1)) {
            neighbors.push(nodes[y - 1][x]);
            n0 = true;
        }
        // direita
        if (this.isWalkableAt(x + 1, y)) {
            neighbors.push(nodes[y][x + 1]);
            n1 = true;
        }
        // baixo
        if (this.isWalkableAt(x, y + 1)) {
            neighbors.push(nodes[y + 1][x]);
            n2 = true;
        }
        // esquerda
        if (this.isWalkableAt(x - 1, y)) {
            neighbors.push(nodes[y][x - 1]);
            n3 = true;
        }
        
        return neighbors;
    }
    AStar();
    function AStar(option) {
        option = option || {};
        //weight = option.weight || 1;
        FindPath(nodeA.x, nodeA.y, nodeB.x, nodeB.y, grid);
    }
    
    function FindPath(startX, startY, endX, endY, grid) {
        var openList = (function(nodeStart, nodeEnd) {
            return nodeA.f, nodeB.f;
        }),
            startNode = getNodeAt(startX, startY),
            endNode = getNodeAt(endX, endY),
            weight = this.weight,
            abs = Math.abs, SQRT2 = Math.SQRT2,
            node, neighbors, neighbor, i, l, x, y, ng;
        
        startNode.g = 0;
        startNode.f = 0;
        openList.push(startNode);
        startNode.opened = true;
        
        // while the open list is not empty
        while (!openList.empty()) {
            // pop the position of node which has the minimum `f` value.
            node = openList.pop();
            node.closed = true;

            // if reached the end position, construct the path and return it
            if (node === endNode) {
                return Util.backtrace(endNode);
            }

            // get neigbours of the current node
            neighbors = grid.getNeighbors(node, diagonalMovement);
            console.log(neighbors);
            for (i = 0, l = neighbors.length; i < l; ++i) {
                neighbor = neighbors[i];
                
                if (neighbor.closed) {
                    continue;
                }

                x = neighbor.x;
                y = neighbor.y;

                // get the distance between current node and the neighbor
                // and calculate the next g score
                ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

                // check if the neighbor has not been inspected yet, or
                // can be reached with smaller cost from the current node
                if (!neighbor.opened || ng < neighbor.g) {
                    neighbor.g = ng;
                    neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = node;

                    if (!neighbor.opened) {
                        openList.push(neighbor);
                        neighbor.opened = true;
                    } else {
                        // the neighbor can be reached with smaller cost.
                        // Since its f value has been updated, we have to
                        // update its position in the open list
                        openList.updateItem(neighbor);
                    }
                }
            } // end for each neighbor
        } // end while not open list empty
        
        // fail to find the path
        return [];
    }
    
    function manhattan(dx, dy) {
        return dx + dy;
    }*/
</script>
    
</body>
</html>